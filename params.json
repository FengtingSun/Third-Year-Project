{
  "name": "Third year project - An eLearning Resource for a Computer Science Topic",
  "tagline": "COMP23111 Database Lecture 1(Introduction to Data Management)",
  "body": "# Introduction to Data Management\r\n### Fundamentals of Databases\r\nAlvaro A A Fernandes, SCS, UoM\r\n[COMP23111 Lecture 01 of 12]\r\n\r\n***\r\n\r\n## Database Management Systems\r\n*   Database management systems (DBMSs)can be seen in the broader context of software engineering strategies.\r\n*   Engineering software is hard and costly.\r\n*   It is not cost-effective to develop every piece of software\r\n    *       from scratch\r\n    *       in a bespoke way\r\n*   We factor out certain functionalities into software products that act as service providers for applications.\r\n    *   We don't build bespoke operating systems (OSs) from scratch.\r\n    *   The services they provide are universally useful and comprise a stable set\r\n*   DBMSs, like OSs, factor out functionalities as services that they provide for applications because it has been shown over decades that\r\n    *   data-related services are universally useful\r\n    *   there is a stable set of them\r\n*   For that, DBMSs enforce\r\n    *   several principles (such as logical/physical independence)\r\n    *   using advanced techniques (such as transaction and recovery management)\r\n    *   that emerge to software engineers as a design methodology\r\n*   This is what we'll learn in this course unit.\r\n\r\n## How do we view data? How should we manage it?\r\n*   Data is an asset, as crucial to an organization as capital or human resources\r\n*   A database management systems (DBMS) is a sophisticated tool for managing data intra- and inter-organizationally.\r\n*   It exposes services that allow people and applications to have a single, unified view of the organization through its data assets.\r\n\r\n![DBMS Flow Chart](https://raw.githubusercontent.com/FengtingSun/Third-Year-Project/Pictures/1.png)\r\n  \r\n## Where are DBMSs used?\r\n*   Inside organizations: to support front-end and back-end business processes\r\n*   Across organizations: to allow cooperation and coordination\r\n![DBMS](https://raw.githubusercontent.com/FengtingSun/Third-Year-Project/Pictures/2.png)\r\n\r\n\r\n## Why DBMSs? Why not use files?\r\n![The reason of using DBMS](https://raw.githubusercontent.com/FengtingSun/Third-Year-Project/Pictures/3.png)\r\n\r\n*   The applications that matter to an organization change\r\nfaster than the data they use.\r\n*   Better to loosely couple application and data.\r\n*   This also allows decoupling a logical view of data from storage technology and formats.\r\n*   A DBMS enables such decoupling, so applications can change as needed.\r\n*   A DBMS therefore lowers the cost of developing new applications.\r\n*   A DBMS offers a set of sophisticated services beyond storage:\r\n    *   Efficient, scalable querying and updating\r\n    *   Concurrent, fault-tolerant transactions\r\n    *   Privacy, and role-based access and authorization control\r\n\r\n## How do different levels of abstraction in DBMSs work?\r\n*   Physical\r\n    *   formats,records,files, clustering, indexes, compression, replication, redundancy\r\n    *   capturedbyastorage model\r\n![DBMS](https://raw.githubusercontent.com/FengtingSun/Third-Year-Project/Pictures/4.png)\r\n***\r\n\r\n*   Logical\r\n    *   what applications need\r\n        *   supplier, product, stock_unit, customer, order, payment, etc.\r\n        *   employee, stores, banker, accounts_payable, accounts_receivable, etc.\r\n    *   captured by a (logical/ conceptual) data model\r\n![DBMS](https://raw.githubusercontent.com/FengtingSun/Third-Year-Project/Pictures/5.png)\r\n***\r\n\r\n*   View\r\n    *   Human resource applications do not see balances in bank account\r\n    *   Accountancy applications do not see employee salaries\r\n    *   captured by a database application model\r\n![DBMS](https://raw.githubusercontent.com/FengtingSun/Third-Year-Project/Pictures/6.png)\r\n\r\n    \r\n## What is a (logical) data model?\r\n*   A formal construct for describing data, their relationship, semantics and constraints\r\n*   Relational is the most widely-used\r\n    *   rowsofcolumnsorganizedin\r\ntables that may reference one another\r\n    *   iftheydo,thennodangling allowed\r\n*   Plus special database languages forinteraction\r\n    *   e.g.,relationalalgebra\r\n    *   A DBMS supports one (or more) data models\r\n    *   The Oracle DBMS, e.g., supports\r\n        *   relational\r\n        *   object-relational\r\n        *   XML-based\r\n        *   document-based\r\n    *   using SQL, XQuery, etc.\r\n\r\n## What are schemas and instances?\r\n*   Each data model defines\r\n    *   whetherthereisadistinct notion of a schema (e.g., recent data models don't)\r\n    *   whattheschemaisallowedto declare (e.g., which structures and which constraints)\r\n*   Then, instances must be valid w.r.t. the schema:\r\n    *   must have compatible structure\r\n    *   must satisfy the constraints\r\n*   A schema defines the logical structure of the database\r\n**share(account,customer)**\r\n*   An instance is the actual content of the database at a particular point in time\r\n**share(015467,'Mary Quaint')\r\nshare(015467,'Vivienne Eastwood)**\r\n*   Schemas are similar to types and variables, instances are similar to variable values (i.e., they change over time)\r\n\r\n## What different types of database language there are?\r\n*   There are different kinds of database language:\r\n    *   DDL: Data Definition Language\r\n    *   DML: Data Manipulation Language\r\n    *   (D)QL: Query Language\r\n*   Again, the terminology is not crisp:\r\n    *   Sometimes, no special DDL\r\n    *   Often, QL is not distinguished from DML\r\n*   The DDL updates the data dictionary\r\n*   It is a declaration language, it defines the schema (i.e., types and constraints)\r\n*   The DML updates the database\r\n*   It is a state-transition language, it changes values (e.g., rows and columns)\r\n*   The QL is a pure expression language, evaluation returns values without changing the database instance\r\n\r\n## Why are different types of database language needed?\r\n*   The main advantage of this approach is enforcing separation of concerns, e.g.\r\n    *   DDL is enterprise-wide, for all applications\r\n    *   DML is for reflecting changes in state\r\n    *   QL is for retrieving information\r\n    *   The lack of assignment makes QL easier to rewrite for optimization purposes\r\n*   In practice, the distinction is not often enforced.\r\n*   SQL⊇DDL∪DML∪QL\r\n*   SQL has become extremely expressive with modern extensions.\r\n\r\n## In the Next Lecture\r\n*   We'll have a closer look at the internal architecture of a DBMS.\r\n*   We'll also look at the various ways in which DBMSs can be deployed in very large scales.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}